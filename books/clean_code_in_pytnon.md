# "Clean Code in Python: Develop maintainable and efficient code" Mariano Anaya

### Context managers
`__enter__` and `__exit__` для реализации контекстного менеджера.

`__exit__` также выхватывает исключения из основного блока, поэтому если возвращать `True`, то потенциально можем пропустить это исключение
Используется не только как очищение ресурсов, но и как изоляция кода.

Хорошая практика обязательно что-то возвращать в `__enter__`.

Для реализации функции можно использовать contextlib и декоратор
`@contextmanager`

### Underscores
Неочевидное поведение для полей двойным подчеркивание, выскакивает исключение об отсутствии атрибута и оно записывается в принципе под другим именем: _класс__атрибут, если хочется private, то лучше использовать одно подчеркивание

### Итераторы
Итераторы по сути являются сущностью, что предоставляет доступ к следующему элементу коллекции или
выбрасывающей исключение StopIteration в случае выхода за предел коллекции.

Соответственно цикл for является реализацией получения итератора коллекции/объекта  через функцию `iter()` и передачи его в `next()`

### Design by contract
Выделим части кода:

- Предусловия - валидация данных на входе
- Постусловия - валидация результата
- Инварианты
- Побочные эффекты 

Разработка идёт по так называемому контракту, где каждый модуль/класс/функция имеет четыре вышеупомянутые части и в случае ошибки сразу же выбрасывает исключение. Каждая функция работает с валидацией своих предусловий и проверкой чужих постусловий. Также необходима максимальная изоляция

### Исключения
Первое и самое важное: не оставляем пустой блок except. Это не выразительно, не очевидно и оставляет дыры в безопасности и надёжности кода.
Как минимум вызов логгера. 

Во-вторых, не доставляем пользователю сам текст исключения, тут тоже причина безопасности вашей программы.
Самый удобный и лаконичный вариант - короткие обобщенные сообщения, как в http протоколе: "страница не найдена", "прервано соединение" и т.д.

В-третьих, когда меняем тип исключения, то используем синтаксис `raise NewTypeException from ValueError`, к примеру.
Предыдущее исключение будет лежать в cause.

Ну и напоследок: не пытайтесь ловить в except `AssertionError`.
