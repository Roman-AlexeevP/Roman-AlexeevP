# "Clean Code in Python: Develop maintainable and efficient code" Mariano Anaya

## Context managers
`__enter__` and `__exit__` для реализации контекстного менеджера.

`__exit__` также выхватывает исключения из основного блока, поэтому если возвращать `True`, то потенциально можем пропустить это исключение
Используется не только как очищение ресурсов, но и как изоляция кода.

Хорошая практика обязательно что-то возвращать в `__enter__`.

Для реализации функции можно использовать contextlib и декоратор
`@contextmanager`

## Underscores
Неочевидное поведение для полей двойным подчеркивание, выскакивает исключение об отсутствии атрибута и оно записывается в принципе под другим именем: _класс__атрибут, если хочется private, то лучше использовать одно подчеркивание

## Итераторы
Итераторы по сути являются сущностью, что предоставляет доступ к следующему элементу коллекции или
выбрасывающей исключение StopIteration в случае выхода за предел коллекции.

Соответственно цикл for является реализацией получения итератора коллекции/объекта  через функцию `iter()` и передачи его в `next()`

## Design by contract
Выделим части кода:

- Предусловия - валидация данных на входе
- Постусловия - валидация результата
- Инварианты
- Побочные эффекты 

Разработка идёт по так называемому контракту, где каждый модуль/класс/функция имеет четыре вышеупомянутые части и в случае ошибки сразу же выбрасывает исключение. Каждая функция работает с валидацией своих предусловий и проверкой чужих постусловий. Также необходима максимальная изоляция

## Исключения
Первое и самое важное: не оставляем пустой блок except. Это не выразительно, не очевидно и оставляет дыры в безопасности и надёжности кода.
Как минимум вызов логгера. 

Во-вторых, не доставляем пользователю сам текст исключения, тут тоже причина безопасности вашей программы.
Самый удобный и лаконичный вариант - короткие обобщенные сообщения, как в http протоколе: "страница не найдена", "прервано соединение" и т.д.

В-третьих, когда меняем тип исключения, то используем синтаксис `raise NewTypeException from ValueError`, к примеру.
Предыдущее исключение будет лежать в cause.

Ну и напоследок: не пытайтесь ловить в except `AssertionError`.

## DRY/OAOO

__Don't Repeat Yourself__
__Once and Only Once__

1. Сложно в рефакторинге(требуются изменения в каждом модуле);
2. Съедает время при написании;
3. Если разработчик, написавший это не задокументировал достаточно, то становимся заложниками его знаний.

В основном дубликации возникают, если не понятно какую конкретно проблему предметной области решает повторяющийся фрагмент кода.

## YAGNI

__You Ain't Gonna Need It__

Преждевременная оптимитизация или же "Я продумаю все на тысячу шагов вперед". 
Вредит тем, что подрывает дедлайны, увеличивает шансы утонуть в изобретении собственных велосипедов. Требования к продукту часто меняются, проблеиы решаемые кодом соответственно тоже. Поэтому надо концентрироваться на текущих проблемах и конкретных способах как их решить. Если изменения действительно будут, тогла уже и стоит задумываться о дополнительных слоях абстракций и паттернов.

## KIS

__Keep It Simple__

В противовес DRY мы не должны в попытках искоренения 3 строчек-дубликатов изобретать декоратор на 20 строк, или без надобности использовать мета-классы.
Самое главное - использовать минимально подходящую структуру данных и не пытаться усложнять себе жизнь попытками переписывания чего-либо на низком-уровне.
Если найдена абстракция для упрощения тех самых 3 строк и она по-прежнему оставляет код прозрачным - прекрасно, но в любых других случаях необходимо задуматься о обязательности рефакторинга.

## EAFP/LBYL

__Easier To Ask Forgiveness Than Permission__
__Look Before You Leap__

Для примера этих принципов продемонстрирую очень простой код:

### EAFP

```python
try:
	with open(filename) as f:
		...
except FileNotFoundException as e:
	logger.error(e)
```

### LBYL

```python
if os.path.exissts(filename):
	with open(filename) as f:
		...
```

Первый фрагмент, возможно, является более показательным и удобным для чтения, так как конкретно показывает возможные ошибки и их обработку.
