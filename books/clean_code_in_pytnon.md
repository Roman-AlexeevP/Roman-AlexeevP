# "Clean Code in Python: Develop maintainable and efficient code" Mariano Anaya

## Context managers
`__enter__` and `__exit__` для реализации контекстного менеджера.

`__exit__` также выхватывает исключения из основного блока, поэтому если возвращать `True`, то потенциально можем пропустить это исключение
Используется не только как очищение ресурсов, но и как изоляция кода.

Хорошая практика обязательно что-то возвращать в `__enter__`.

Для реализации функции можно использовать contextlib и декоратор
`@contextmanager`

## Underscores
Неочевидное поведение для полей двойным подчеркивание, выскакивает исключение об отсутствии атрибута и оно записывается в принципе под другим именем: _класс__атрибут, если хочется private, то лучше использовать одно подчеркивание

## Итераторы
Итераторы по сути являются сущностью, что предоставляет доступ к следующему элементу коллекции или
выбрасывающей исключение StopIteration в случае выхода за предел коллекции.

Соответственно цикл for является реализацией получения итератора коллекции/объекта  через функцию `iter()` и передачи его в `next()`

## Design by contract
Выделим части кода:

- Предусловия - валидация данных на входе
- Постусловия - валидация результата
- Инварианты
- Побочные эффекты 

Разработка идёт по так называемому контракту, где каждый модуль/класс/функция имеет четыре вышеупомянутые части и в случае ошибки сразу же выбрасывает исключение. Каждая функция работает с валидацией своих предусловий и проверкой чужих постусловий. Также необходима максимальная изоляция

## Исключения
Первое и самое важное: не оставляем пустой блок except. Это не выразительно, не очевидно и оставляет дыры в безопасности и надёжности кода.
Как минимум вызов логгера. 

Во-вторых, не доставляем пользователю сам текст исключения, тут тоже причина безопасности вашей программы.
Самый удобный и лаконичный вариант - короткие обобщенные сообщения, как в http протоколе: "страница не найдена", "прервано соединение" и т.д.

В-третьих, когда меняем тип исключения, то используем синтаксис `raise NewTypeException from ValueError`, к примеру.
Предыдущее исключение будет лежать в cause.

Ну и напоследок: не пытайтесь ловить в except `AssertionError`.

## DRY/OAOO

__Don't Repeat Yourself__
__Once and Only Once__

1. Сложно в рефакторинге(требуются изменения в каждом модуле);
2. Съедает время при написании;
3. Если разработчик, написавший это не задокументировал достаточно, то становимся заложниками его знаний.

В основном дубликации возникают, если не понятно какую конкретно проблему предметной области решает повторяющийся фрагмент кода.

## YAGNI

__You Ain't Gonna Need It__

Преждевременная оптимитизация или же "Я продумаю все на тысячу шагов вперед". 
Вредит тем, что подрывает дедлайны, увеличивает шансы утонуть в изобретении собственных велосипедов. Требования к продукту часто меняются, проблеиы решаемые кодом соответственно тоже. Поэтому надо концентрироваться на текущих проблемах и конкретных способах как их решить. Если изменения действительно будут, тогла уже и стоит задумываться о дополнительных слоях абстракций и паттернов.

## KIS

__Keep It Simple__

В противовес DRY мы не должны в попытках искоренения 3 строчек-дубликатов изобретать декоратор на 20 строк, или без надобности использовать мета-классы.
Самое главное - использовать минимально подходящую структуру данных и не пытаться усложнять себе жизнь попытками переписывания чего-либо на низком-уровне.
Если найдена абстракция для упрощения тех самых 3 строк и она по-прежнему оставляет код прозрачным - прекрасно, но в любых других случаях необходимо задуматься о обязательности рефакторинга.

## EAFP/LBYL

__Easier To Ask Forgiveness Than Permission__
__Look Before You Leap__

Для примера этих принципов продемонстрирую очень простой код:

### EAFP

```python
try:
	with open(filename) as f:
		...
except FileNotFoundException as e:
	logger.error(e)
```

### LBYL

```python
if os.path.exissts(filename):
	with open(filename) as f:
		...
```

Первый фрагмент, возможно, является более показательным и удобным для чтения, так как конкретно показывает возможные ошибки и их обработку.

# Декораторы
Конструкция языка и паттерн проектирования для выделения нового слоя абстракции вокруг изменяемого объекта, минимально изменяя его функционал, например: скорость выполнения функции, повторный запуск с контролируемым исключением, сериализация данных 

## Как задаются декораторы в python

Классическая форма декоратора - использование функций высшего порядка(тех, которые берут в аргументы другие функции):

```py
def timer(function):
	@wraps(function)
	def wrapped(*args, **kwargs):
		start_time = tiem.time()
		function(*args, **kwargs)
		end_time = time.time()
		print(f"Time for function {function.__name__}: {end_time-start_time}")
		
	return wrapped
```

Теперь декоратор в виде класса с использованием магического метода `__call__()`, для примера напишем декоратор с повторным запуском функции в случае заданного исключения:

```py
class WithRetry():
	
	def __init__(self,
	 	retries_limit: int = DEFAULT_RETRIES_LIMIT,
	 	allowed_exceptions:Optional[Sequence[Exception]] = None) -> None:
		self.retries_limit = retries_limit
		self.allowed_exceptions = allowed_exceptions or (ControlledException, )

	def __call__(self, operation):
		@wraps(operation)
		def wrapped(*args, **kwargs):
			last_raised_exception = None
			for _ in range(self.retries_limit):
				try:
					operation(*args, **kwargs)
				except self.allowed_exceptions as e:
					logger.warning(f"retrying {operation.__qualname__} due to {e}")
					last_raised_exception = e
			raise last_raised_exception
		return wrapped

@WithRetry(retries_limit=5)
def run_with_retries_limit(task):
	return task.run()
		
```

Передача аргументов в функцию-декоратор происходит через добавление третьей функции, принимающей аргументы для самого декоратора:

```py
def retry(retries_limit: int = DEFAULT_RETRIES_LIMIT,
	 	allowed_exceptions:Optional[Sequence[Exception]] = None):
	 	def decorator_function(operation):
	 		@wraps(operation)
	 		def wrapped(*args, **kwargs):
	 			allowed_exceptions = allowed_exceptions or (ControlledException, )
	 			last_raised_exception = None
				for _ in range(retries_limit):
					try:
						operation(*args, **kwargs)
					except allowed_exceptions as e:
						logger.warning(f"retrying {operation.__qualname__} due to {e}")
						last_raised_exception = e
				raise last_raised_exception
			return wrapped
		return decorator_function

```


## Польза декораторов и возможные пути использования 

- Отслеживание кода

Всевозможное профилирование кода, отслеживание логов и работа с исключениями - все это отличные абстракции, реализуемые декоратором

- Преобразование параметров

Работа с легаси или импортируемой библиотекой для более прозрачного и ясного интерфейса также может быть решена с помиощью декоратора,
 только в данном случае необходимо понимать, что происхожите действительно упрощение, а не дальнейшее усложнение использования функции

- Валидация данных

В данной случае мы можем проверять предусловия наших абстракций, если следуем методике разработке по контракту(DbС)

- Механизм повторного запуска функций

См. выше примеры

- Вынесение общего из классов в декоратор(DRY)

## Ошибки при использовании декораторов

1. Игнорирование или незнание functools.wraps: без данного декоратора метаданные оборачиваемой функции не будут доступны внутри декоратора(например __qualname__ будет функции из декоратора, а не обернутой им)
2. Вынесение бьольшего количества логики вне wrapped функции и множество побочных эффектов от декоратора может привести к неожиданной работе программы
3. Создание декоратора первым делом, до понимания абстракции. Для соблюдения DRY мы начинаем с начала работы с коды создавать декораторы и продумывать их логику, что является достаточно сильным усложнением программы и преждевременной оптимизацией. Лучше дождаться использования минимум 3 раз данного концепта и тогда уже создавать абстракцию.


